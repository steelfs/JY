 F5 => 다음 중단점으로 점프 

delegate는 외부로 신호를 보내는 것 뿐만 아니라 클레스 내부에서 사용할때도 유용하게 쓰이는 것 같다.

UI의 LocalPosition을 변경하려면 RectTransform 을 찾아와서 anchoredPosition을 바꿔주면 된다

------------------------------------------------------------------------------------------------------------------------------------------------------------
2023-07-09
------------------------------------------------------------------------------------------------------------------------------------------------------------
 RemoveAt, Insert를 이용해 List내부구조의 순서를 바꾸려 할 때  RemoveAt을 연속적으로 사용하면 자시 Insert하는 과정에서 인덱스가 밀리는 현상이 생기므로 
만약 두개를 한다면 Remove 후 Insert를 하고 번갈아가면서 두번 실행해 주어야 한다. 만약 Remove를 두번 실행한 후 Insert를 두번 실행하면 인덱스가 한칸씩 밀려서
나중에 추가하려는 인덱스가 존재하지 않게되는 문제가 발생한다.

추가로 List의 인덱스가 만약 5까지 있다면 6번째 인덱스에는 추가가 가능하지만 7번째 인덱스에 추가하려 하면 outOfRange 에러가 뜨게 된다

UI 오브젝트가 부모의 크기 범위를 벗어나더라도 화면에 렌더링 하게 하려면 상위 오브젝트중 Mask 컴포넌트를 비활성화, 제거하면 된다.
반대로 제한하려면 추가하면 된다

------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 10일
------------------------------------------------------------------------------------------------------------------------------------------------------------
어떤 오브젝트의 참조를 가져올 때 현재 씬에 배치되어있는 오브젝트와 프리펩에 있는 Object는 다른 오브젝트로 취급된다.
Prefab 을 인스펙터창에서 할당해도 현제 씬에 올라와있는 오브젝트를 불러오지 못한다.
------------------------------------------------------------------------------------------------------------------------------------------------------------
Slot의 위치에 description을 팝업하려 할 때 두 오브젝트의 앵커위치가 다르기때문에 anchoredPosition을 기준으로 정렬하는 것은 원치않는 결과를 보여주게 된다.

7월 12일
------------------------------------------------------------------------------------------------------------------------------------------------------------
씬메니저의 로드씬 함수 동기방식 - 함수가 실행될때 다른 것들은 모두 스탑
------------------------------------------------------------------------------------------------------------------------------------------------------------
string NectSceneName = "~~"
변수이름의 앞글자로 대문자로 하니 왠지 씬을 불러올 수 없었다.
NectSceneName  을 nectSceneName 으로 고치지 에러가 없어졌다. 왜그런지는 모르겠다.
------------------------------------------------------------------------------------------------------------------------------------------------------------

7월 14일
------------------------------------------------------------------------------------------------------------------------------------------------------------
카메라의 이동영역을 제한하기 위해선 반드시 composite collider가 필요하다

 // lifeTimeText.text = $"{(maxLifeTime * ratio) : f2} sec";     => 틀린코드
 // lifeTimeText.text = $"{(maxLifeTime * ratio) :f2} sec";     => 정확한 코드 콜론 : 과 f2사이에 스페이스가 있으면 소숫점을 표시하지 않고 "f2" 로 화면상에 표시된다

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
230715
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
로컬파일을 유니티 에디터로 드래그드롭 으로 추가할 때는 Probuilder 와같은 Package가 설치된 살태에서 옮겨줘야  누락된 파일없이 작동한다(옮기기 전 프로젝트와 동일한 환경 조성)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
string.Remove(index) 함수를 사용하더라도 이미 값이 앞서 정해진 string의 값은 변하지 않는다.
따라서 처음 선언 할때부터 Remove를 사용해서 할당해야한다.
예를들면 string name = "Name"
	name.Remove(2); 를 실행해도 name의 값은 바뀌지 않는다 따라서 재정의하고싶다면 다음과 같이 해야한다.
	
	string newName = name.Remove(2); 를 실행하면 newName의 값은 2번째 인덱스부터 지워진 값인 "na" 만 남게된다
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
230716
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
가우스덧셈 공식
(n / 2) * (n / 2 + 1);
(n / 2) = 페어의 갯수.
(n / 2 + 1) = 첫번째 숫자와 마지막 숫자의 합. 원래는 (n + 1) 이지만 홀수 혹은 짝수의 합만 더하려는 경우라서 먼저 /2를 해 주었다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

230717
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
이모트 에셋 애니메이션  프리팹모델 => Rig => AnumationType Humanoid check
				Animation Re targetting
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Character Cotroller
StepOffset = 극복가능한 높이 
slope Limit =극복가능한 경사도 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 18일
Particle System
PreWarm 시작할때 이미 생성이 되있는 상태
startSpeed 움직이는 속도

Play On Awake
게임시작시 자동시작 or 수동으로 플레이 할 건지 결정
Max Particle 갯수 제한
StopAction - 재생이 끝난 후 액션
Culling Mode 카메라에 랜더링 되지 않을때 어떻게 할 것인가

Renderer
BillBoard 기법 간단한 눈속임 판때기를 시야의 각도로 회전시켜서 3D처럼 느끼게 함
sortmode 설정시 연산이 많아 진다. 


Emission,
	rate over time - 몇개를 생성할 것인가  10 - 초당 10개 생성
	rate over distance - 움직인 거리에 비례해서 갯수를 증가시킨다
	burst - 폭발적으로 한번에 생성

Shape
	어떤 모양으로 파티클을 뿌릴 것인가

Material Shader - URP - Particle - Unlit
---------------------------------------------------------------------------------------------------------------------------------------------------
7월 19일
  wayPoint1 = GameObject.Find("Waypoint1").GetComponent<Transform>(); 는 가능한데 
  waypoints[0] = wayPoint1_Object.GetComponent<Transform>(); 는 안되는 이유

  Transform[] waypoints;
을 선언한 이후 
아직 waypoints 배열의 갯수는 직접 변경이 불가능 하기 때문에 
new 연산자를 사용해서 먼저 새로 배열을 만들어 준 후 할당해야 정상 작동한다.

결과적으로 
  waypoints[0] = wayPoint1_Object.transform; 를 해주기 전에 
waypoints = new Transform[2]; 으로 배열을 새로 만들어준 후 할당해야한다

7월 21일
애니메이션 직접 연결 말고 Exit으로 연결도 가능
StateMachineBehaviour 의 OnStateExit는 하나의 애니메이션이 종료될 때 실행되지만 해당 애니메이션이 StateMachine 안에 있다면,
				 해당 애니메이션이 끝나고 Exit으로 이동해서 소속된 해당 StateMachine이 끝나야 호출이 된다.
	또한 IdelSelect 의 값이 몇이든 상관 없이 무조건 defaultState로 이동하는 문제
	OnstateEnter에서 player의 무기와 방패를 SetActive(False) 로 하고있지만 Default State로 이동하면 다시 true가 되는 현상이 있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    public ItemData this[ItemCode code] => itemDatas[(int)code];
 this 부분에는 ItemData 가 들어가는게 아니라  위 코드를 정의한 클래스를 넣어줘야 한다.

위 인덱서를 사용하면 굳이 string name = Enum.GetName() 같은 함수를 쓰지않아도 될 것 같다.