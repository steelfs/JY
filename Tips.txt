 F5 => 다음 중단점으로 점프 

delegate는 외부로 신호를 보내는 것 뿐만 아니라 클레스 내부에서 사용할때도 유용하게 쓰이는 것 같다.

UI의 LocalPosition을 변경하려면 RectTransform 을 찾아와서 anchoredPosition을 바꿔주면 된다

------------------------------------------------------------------------------------------------------------------------------------------------------------
2023-07-09
------------------------------------------------------------------------------------------------------------------------------------------------------------
 RemoveAt, Insert를 이용해 List내부구조의 순서를 바꾸려 할 때  RemoveAt을 연속적으로 사용하면 자시 Insert하는 과정에서 인덱스가 밀리는 현상이 생기므로 
만약 두개를 한다면 Remove 후 Insert를 하고 번갈아가면서 두번 실행해 주어야 한다. 만약 Remove를 두번 실행한 후 Insert를 두번 실행하면 인덱스가 한칸씩 밀려서
나중에 추가하려는 인덱스가 존재하지 않게되는 문제가 발생한다.

추가로 List의 인덱스가 만약 5까지 있다면 6번째 인덱스에는 추가가 가능하지만 7번째 인덱스에 추가하려 하면 outOfRange 에러가 뜨게 된다

UI 오브젝트가 부모의 크기 범위를 벗어나더라도 화면에 렌더링 하게 하려면 상위 오브젝트중 Mask 컴포넌트를 비활성화, 제거하면 된다.
반대로 제한하려면 추가하면 된다

------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 10일
------------------------------------------------------------------------------------------------------------------------------------------------------------
어떤 오브젝트의 참조를 가져올 때 현재 씬에 배치되어있는 오브젝트와 프리펩에 있는 Object는 다른 오브젝트로 취급된다.
Prefab 을 인스펙터창에서 할당해도 현제 씬에 올라와있는 오브젝트를 불러오지 못한다.
------------------------------------------------------------------------------------------------------------------------------------------------------------
Slot의 위치에 description을 팝업하려 할 때 두 오브젝트의 앵커위치가 다르기때문에 anchoredPosition을 기준으로 정렬하는 것은 원치않는 결과를 보여주게 된다.

7월 12일
------------------------------------------------------------------------------------------------------------------------------------------------------------
씬메니저의 로드씬 함수 동기방식 - 함수가 실행될때 다른 것들은 모두 스탑
------------------------------------------------------------------------------------------------------------------------------------------------------------
string NectSceneName = "~~"
변수이름의 앞글자로 대문자로 하니 왠지 씬을 불러올 수 없었다.
NectSceneName  을 nectSceneName 으로 고치지 에러가 없어졌다. 왜그런지는 모르겠다.
------------------------------------------------------------------------------------------------------------------------------------------------------------

7월 14일
------------------------------------------------------------------------------------------------------------------------------------------------------------
카메라의 이동영역을 제한하기 위해선 반드시 composite collider가 필요하다

 // lifeTimeText.text = $"{(maxLifeTime * ratio) : f2} sec";     => 틀린코드
 // lifeTimeText.text = $"{(maxLifeTime * ratio) :f2} sec";     => 정확한 코드 콜론 : 과 f2사이에 스페이스가 있으면 소숫점을 표시하지 않고 "f2" 로 화면상에 표시된다

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
230715
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
로컬파일을 유니티 에디터로 드래그드롭 으로 추가할 때는 Probuilder 와같은 Package가 설치된 살태에서 옮겨줘야  누락된 파일없이 작동한다(옮기기 전 프로젝트와 동일한 환경 조성)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
string.Remove(index) 함수를 사용하더라도 이미 값이 앞서 정해진 string의 값은 변하지 않는다.
따라서 처음 선언 할때부터 Remove를 사용해서 할당해야한다.
예를들면 string name = "Name"
	name.Remove(2); 를 실행해도 name의 값은 바뀌지 않는다 따라서 재정의하고싶다면 다음과 같이 해야한다.
	
	string newName = name.Remove(2); 를 실행하면 newName의 값은 2번째 인덱스부터 지워진 값인 "na" 만 남게된다
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
230716
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
가우스덧셈 공식
(n / 2) * (n / 2 + 1);
(n / 2) = 페어의 갯수.
(n / 2 + 1) = 첫번째 숫자와 마지막 숫자의 합. 원래는 (n + 1) 이지만 홀수 혹은 짝수의 합만 더하려는 경우라서 먼저 /2를 해 주었다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

230717
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
이모트 에셋 애니메이션  프리팹모델 => Rig => AnumationType Humanoid check
				Animation Re targetting
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Character Cotroller
StepOffset = 극복가능한 높이 
slope Limit =극복가능한 경사도 

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 18일
Particle System
PreWarm 시작할때 이미 생성이 되있는 상태
startSpeed 움직이는 속도

Play On Awake
게임시작시 자동시작 or 수동으로 플레이 할 건지 결정
Max Particle 갯수 제한
StopAction - 재생이 끝난 후 액션
Culling Mode 카메라에 랜더링 되지 않을때 어떻게 할 것인가

Renderer
BillBoard 기법 간단한 눈속임 판때기를 시야의 각도로 회전시켜서 3D처럼 느끼게 함
sortmode 설정시 연산이 많아 진다. 


Emission,
	rate over time - 몇개를 생성할 것인가  10 - 초당 10개 생성
	rate over distance - 움직인 거리에 비례해서 갯수를 증가시킨다
	burst - 폭발적으로 한번에 생성

Shape
	어떤 모양으로 파티클을 뿌릴 것인가

Material Shader - URP - Particle - Unlit
---------------------------------------------------------------------------------------------------------------------------------------------------
7월 19일
  wayPoint1 = GameObject.Find("Waypoint1").GetComponent<Transform>(); 는 가능한데 
  waypoints[0] = wayPoint1_Object.GetComponent<Transform>(); 는 안되는 이유

  Transform[] waypoints;
을 선언한 이후 
아직 waypoints 배열의 갯수는 직접 변경이 불가능 하기 때문에 
new 연산자를 사용해서 먼저 새로 배열을 만들어 준 후 할당해야 정상 작동한다.

결과적으로 
  waypoints[0] = wayPoint1_Object.transform; 를 해주기 전에 
waypoints = new Transform[2]; 으로 배열을 새로 만들어준 후 할당해야한다

7월 21일
애니메이션 직접 연결 말고 Exit으로 연결도 가능
StateMachineBehaviour 의 OnStateExit는 하나의 애니메이션이 종료될 때 실행되지만 해당 애니메이션이 StateMachine 안에 있다면,
				 해당 애니메이션이 끝나고 Exit으로 이동해서 소속된 해당 StateMachine이 끝나야 호출이 된다.
	또한 IdelSelect 의 값이 몇이든 상관 없이 무조건 defaultState로 이동하는 문제
	OnstateEnter에서 player의 무기와 방패를 SetActive(False) 로 하고있지만 Default State로 이동하면 다시 true가 되는 현상이 있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    public ItemData this[ItemCode code] => itemDatas[(int)code];
 this 부분에는 ItemData 가 들어가는게 아니라  위 코드를 정의한 클래스를 넣어줘야 한다.

위 인덱서를 사용하면 굳이 string name = Enum.GetName() 같은 함수를 쓰지않아도 될 것 같다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 26일
UI오브젝트의 크기를 구하고싶으면 rectTransform 의 sizeDelta를 이용하면 된다.
또한 스크린 클레스의  Screen.Width, height 를 사용하면 화면의 너비를 구할 수 있다.

비활성화된 오브젝트를 대상으로 GetComponent를 하면 null 이 할당된다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 27일

        Debug.Log($"{1 - Mathf.Cos(timeElapsed)}");  결과는 0 ~ 2 범위를 반환한다.  Mathf.Cos(timeElapsed) 의값은1과 -1 사이를 반복하는데 1 이면 1 - 1 = 0 이 되고
											     -1이 되면  -1 - (-1) 이 되기때문에 결과적으로 2가 된다.

        Debug.Log($"{0.5 *(1 - Mathf.Cos(timeElapsed))}");  위 값에 0.5를 곱하면 0일때 0이고 2일때 1이 되기 때문에 0 ~ 1 사이를 반복하게 된다.


       Debug.Log($"{(0.5 *(1 - Mathf.Cos(timeElapsed))) * (maxY - minY)}");  위 값에 (maxY - minY)를 곱해서 진폭을 키워준다.


       Debug.Log($"{minY + (0.5 *(1 - Mathf.Cos(timeElapsed))) * (maxY - minY)}"); 그 다음 거기에 minY를 더해서 최소값을 더해주면 원하는 범위내를 반복할 수 있게 된다.


	
	정리하자면   (maxY - minY)를 곱하는 이유는 원하는 만큼의 진폭을 키워주기 위함이고 minY 를 더해주는 이유는 최솟값을 보정하기 위함이며 
	
	0.5 *(1 - Mathf.Cos(timeElapsed) :        Mathf.Cos(timeElapsed) 의 값에 1을빼는 이유는 음수가 나오지 않게 하기 위함이며, 0.5를 곱하는 이유는  곱해서 뻥튀기된 최댓값을
	다시 원위치 시키기 위함이다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 28일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
        if( canvasGroup.alpha > 0.0f )      // 보이는 상황일 때만
        {
            RectTransform rectTransform = (RectTransform)transform;     // rectTransform 가져오기

            int overX = (int)(screenPos.x + rectTransform.sizeDelta.x) - Screen.width;  // 화면 밖으로 넘친 정도를 계산
            overX = Mathf.Max(0, overX);        // 음수 제거(음수면 정상 범위)
            screenPos.x -= overX;               // 넘친만큼 왼쪽으로 이동시키기

            transform.position = screenPos;     // 이동 시키기
        }
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	
	rectTransform.sizeDelta.x = 고정값. 현재 500으로 가정
	 Debug.Log(screenPos.x); = 1920 * 1080 스크린의 좌표중 마우스의 위치
    	Debug.Log(Screen.width); = 스크린의 x크기 1920 고정

	따라서 screenPos.x + rectTransform.sizeDelta.x 의 값이 Screen.width 보다 그면 화면의 오른쪽 범위를 벗어났다는 논리 이므로 
	int overX = (int)(screenPos.x + rectTransform.sizeDelta.x) - Screen.width 의 값이 양수가 나오면 범위를 벗어난 것이고 음수가 나오면 벗어나지 않았다는 것 

	결과적으로 원하는 것은 transform.position 에 넘친만큼의 x값을 빼주고싶은 것이다. 그래서 screenPos.x -= overX;     이렇게 빼주는데 만약 overX가 음수가 될 경우 
	음수를 빼버리므로 오히려 +가 되기 때문에 빼기전에  overX = Mathf.Max(0, overX); 음수를 제거한 뒤 빼주는 것이다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
230730
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
IDragHandler 인터페이스의 eventData.position 은 Mouse.Current.Position.ReadValue 와 같은 값이다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 31일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 List<(ItemData, uint)> sortedData = new List<(ItemData, uint)>(slots.Count);

 foreach (var data in sortedData)
        {
            slots[index].AssignSlotItem(data.Item1, data.Item2);
            index++;
        }

data.Item1, data.Item2  item1 은  ItemData가 되고   item2는 uint 값이 할당된다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 2일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
기능 작성시 
순서 
상태 분류(enum)
상태를 바꾸는 조건 설정,
상태마다 실행될 함수 작성
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

8월 5일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
만약 아이템의 데이터값을 런타임에 수정해야할 이벤트가 생길 거같으면 ex) 아이템 레벨업 
Scriptable Object는 적절한 대안이 아닐 수 있다. 그냥 일반Class가 적합하다.
스크립터블 오브젝트는 게임 시작 전 데이터를 미리 저장하고 그 데이터의 참조를 여러곳에서 가져다 쓸 수 있게 하기 위함이다.
<<<<<<< HEAD
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

8월 6일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
State머신의 상태를 너무 자주바꿔도 함수호출의 타이밍을 잡기가 오히려 안좋은 것같다 
=======
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

8월 7일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Monobehaviour 를 상속받은 것이라면 반드시  게임오브젝트가 아니더라도  T타입이기 때문에 클래스도 Instantiate이 가능하다.  이렇게 하면 
스크립터블 오브젝트도 원본의 참조를 넘기는 것이 아니라 복사본을 생성하게 된다.
이렇게 해서 모든 아이템이 하나의 스크립터블 오브젝트의 데이터를 공유해서 하나의 값이 바뀔 때 모든 아이템의 값이 바뀌는 것을 방지할 수 있다.

 public static T Instantiate<T>(T original) where T : Object 
이기 때문에 Object만 상속받았으면 무엇이든 넣어도 상관없다.

