 for (int i = 0; i < power; i++)
        {
            //총알간 사이각 30도 
            // power 1일 때  0도 회전
            // 2일때 1개는 -15도 1개는 15도 회전
            // 3일 때 -30, 0, 30도 회전 

            fireTransforms[i].rotation = Quaternion.Euler(0, 0, (power - 1) * (fireAngle * 0.5f) + (i * -fireAngle));//power로 시작각 정하고 추가로 i * 발사각만큼 추가
            fireTransforms[i].localPosition = Vector3.zero;
            fireTransforms[i].Translate(0.5f, 0, 0);

            fireTransforms[i].gameObject.SetActive(true);
        }

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 16일
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 미니운석 생성각도 조절 필요 //원인 :    Factory.Inst.GetAsteroidMini(transform.position,startAngle + angle); angle에 i를 곱해주지 않아 모든 운석이 같은 각도로 날아감
 Factory.Inst.GetAsteroidMini(transform.position,startAngle + angle * i);  전달하는 파라미터에 i를 곱해서 해결 

백그라운드 소팅레이어 윗쪽에 있음에도 에너미불릿을 가리는 문제 =>  원인 : 불릿프리팹의 스프라이트 랜더러는 원래 비활성화상태였고 애니매이터를 가진 자식오브젝트의 소팅레이어가
Default로 설정되어있어서 백그라운드에서 가려지던 것
불릿은 자식 애니매이션과 겹치는 문제를 해결하기 위해 스프라이트 랜더러를 비활성화하고
애니매이터를 가진 자식 오브젝트의  소팅레이어를 Enemy로 바꿔서 해결


게임화면에서 캔버스 테두리 보이는 문제 //뭔가 설정에 문제가 있었던 것 같다. 캔버스를 다시 만들고 하위에 GameOver, Score, Life Panel을 추가했는데  캔버스가 화면에 보이지 않았다.

보스 미사일?  불릿 발사속도 조절
원인 : Update 함수 안에서 Y값이 미니멈(-3)보다 작거나 맥시멈(3)보다 클때 MissileFire 코루틴을 호출하는데 처음 등장시 Initialize함수에서 Y값의 위치가 0으로 설정했음에도 
등장위치의 Y값이 미니멈, 맥시멈을 벗어날때  프레임마다 호출되는 문제 발생
Spawner 에서 생성하는 부분이 Y가 4이긴 한데 강사님 스크립트도 4로 되어있는데 왜 나만 문제가 발생하는건지 의문

결국 임시방편으로 MissileFire 호출 조건을 Y값을 비교하는게 아니라 (targetPos - transform.position.y).sqrmagnitude < 0.01f 로 변경해서 해결하긴 했는데 연산량이 더 많아서 찜찜


Onclick 함수에 파라미터를 전달하고싶었는데 직접전달하는것은 안되도 
public void OnBtnClick()
{
	int parameter = 1;
	SumMethod (parameter)	
}
void SumMethod(int a)
{
	
}
위와같이 간접적으로 호출하는 방법이 있었다. 유용하게 사용할 수 있을 것 같다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 17일
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
GameOverPanel 만드는 중 알파값을 조절해서 비활성화된것과 같은 효과를 주고싶었는데 컨포넌트 이름이 기억이 나지 않았다.
컴포넌트 이름 : Canvas Group

-------------------------------------------------------------------------------------------------------------------
LifePanel 스크립트에서 > 빈 오브젝트 > Image, X, Life   를 가져와야하는상황
먼저 빈 오브젝트를 참조할 때 Transform 타입으로 가져와서  그 이후
Transform lifeRoot;

lifeRoot = transform.Getchild(0) 가져온 후 

TextMeshProUGUI life;

life = lifeRoot.GetChild(2).getcomponent<TextMeshProUGUI>(); 로 가져왔다.

lifeRoot를 게임오브젝트 타입으로 가져와도 되나?해서 시도해봤는데 그렇게되면 gameObject타입에는 GetChild 가 없어서 life를 가져올 수 없었다.
따라서 그냥 원래대로 Transform타입으로 lifeRoot를 가져왔다.
-=---------------------------------------------------------------------------------------------------------------------

    private void OnDie()
    {
        Collider2D coll = GetComponent<Collider2D>();
        rigid.freezeRotation = false;
        rigid.gravityScale = 2;
    }

	콜라이더 컴포넌트를 비활성화하기.  gameobject 타입은 setActive를 사용하지만 collider2D는 Enabled = false 이런식으로 사용한다.

----------------------------------------------------------------------------------------------------------------------
스코어 올라가는 속도  MathF.Max(newspeed, (targetScore - currentScore)) 로 해결
------------------------------------------------------------------------------------------------------------------------
죽었을때 좌측으로 이동하며 로테이션 시키기
전역변수 bool 값으로 만든 후 이를 충족할 때만 이동처리 하고 Die함수에서 false시키고 rigid,AddForce(vector2.Left) * 10 ,  Forcemode.Impulse)  이동을 멈추고
 transform.Rotate(vector3.Foward(0,0,1) * 50)  
-------------------------------------------------------------------------------------------------------------------------
비격시 깜빡이는건 애니매이션 하나 만들어서 1.5초정도 사이 알파값에 커브를 줘서 조절, parameter로 trigger 설정 후 스크립트에서 anim.SetTrigger(Invincible) 설정
애니메이터에서 trigger 설정하고 트렌지션만 만들어주면 해당 애니매이션이 끝나면 다시 이전 애니매이션 상태로 돌아간다
--------------------------------------------------------------------------------------------------------------------------------------------------------
Die 함수 안에서 GameOver패널 활성화 시키기

Player 클래스에서 score를 파라메터로 전달하는 onDie Delegate를 만들었다.
그리고 Die함수에서 호출하는 신호를 보낼 때 보통 지금가지 onDie?.Invoke(); 로 널러블 타입을 섰었는데  ?를 빼고 실행해보니 연결된 함수가 없을 경우 
신호를 보내는 시점부터 플레이어와 적의 충돌처리가 되지 않는 등 게임이 정상적으로 작동하지 않았다. 반면 ? 를 붙혀주자 연결된 함수가 없어도 정상적으로 작동하는 모습이다.

GameOverPanel 스크립트에서 Animator anim; anim = Getcomponent<Animator>(); 불러온 후 
start 에서 GameManager.Inst.Player.onDie += (_) => anim.SetTrigger("GameOver");

람다식으로 할당하니 잘 작동하는 모습
-----------------------------------------------------------------------------------------------------------------------------------------------------------
Button -> 씬메니저의 로드씬 함수 연결
GameOverPanel 스크립트에서 Button reStartButton;   	reStartButton = transform.getchild(1).GetComponent<Button>();
awake에서 reStartButton.Onclick.AddListener(reLoadScene);

void reLoadScene()
{
	SceneManager.LoadScene(0);
}
------------------------------------------------------------------------------------------------------------------------------------------

MMO - Unity

transform.rotaion 으로 dir을 주면 
이동할 때 굳이 dir방향이 아니아 Vectoe3.Foward 해줘도 된다

Manager를 싱글톤으로 다시 만들어야겠다.

학원 수업에서 강사님이 이 긴 코드를(싱글톤 코드) 싱글톤 클래스 하나를 만들때마다 귀찮게 쳐줘야하는 단점이있다고 하시면서 
 싱글톤을 <T> 타입으로 여기저기 붙혀서 편리하게 사용할 수 있게끔 알려주셨는데
 우선 그 과정이 귀찮게 느껴지려면 최소 싱글톤이란 것을 눈감고도 만들 수 있을 정도가 되야 귀찮고 지겹다는 말이 성립이 된다.
 즉 지금 실력은 싱글톤을 그냥 만들라고해도 못만드는데 귀찮다는 말은 애초에 성립되지 않는다.

나중에 스스로 정말 귀찮다고 느끼는 순간이 온다면 그때<T> 타입으로 상속해서 사용해야겠다.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 18일
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
class 는 객체를 찍어내기 위한 금형, 빵틀 이라고 생각한다. 그렇기 때문에 static 타입이 아닌 메서드를 호출하기 위해서는 정확히 어떤 객체의 매서드인지 지정을 해주어야
컴파일러 입장에서 혼란스럽지 않다.  그렇지 않으면 메서드를 static 으로 만들어서 이 함수는 하나만 존재한다고 선언을 해주어야 한다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
delegate를 처음 배울 때 프로퍼티를 만들어서 Set 함수를 실행시키면서 원하는 로직을 그 안에 넣어서 호출하면되는데 굳이 왜 delegate를 사용할까 생각했는데
프로퍼티를 사용할 경우 특정 값이 변경될때만 사용할 수 있는 반면 delegate는 원하는 어느타이밍에서든 호출할 수 있는 장점이 있는 것 같다
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Shooting

EnemyStrike 한번 사용후 풀로 동아갔다가 재사용될때 초기 스피드가 너무 빠른 문제
원인 : 코루틴에서 스피드를 빠르게 조정 후 재사용될때 스피드를 초기화 하지 않음 
해결 : 코루틴 시작할때 스피드를 직접 3으로 설정
------------------------------------------------------------------------------------------------------------------------------
EnemyAsteroid  혼자 자폭해도 점수가 올라가는 현상 
SelfCrush 코루틴에서 EnemyBase의 Score를 변경해주려 했으나 읽기전용 프로퍼티라 주성이 불가능함.

해결 : Base 클래스인 EnemyBase 에서 int fixedScore를 파라미터로 받아 score를 변경할수 있는  리턴타입 int 함수를 하나 만들고 SelfCrush에서  시간을 기다렸다가 터지 기 전 
score = AdditScore(0); 을 호출해서 해서 해결
---------------------------------------------------------------------------------------------------------------------------------------------------------------
Monster1 의 이동방향이 고쳐지질 않는다 소환 위치 기준 항상 왼쪽으로 움직여야한다고 생각하는데 왜 오른쪽으로 움직이는 경우가 발생하는지 모르겠다.
방향벡터를 정규화 했을 때 x값이 음수가 나와야하는데 양수가 나오는 이해할 수 없는 현상이 있다

---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 19일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RankUpdate(int score) //1등 -> 5등 까지
    {
        //기존의 점수보다 score가 높으면 랭킹이 갱신되어야 한다
        //새 이름은 임의로 설정
        for (int i = 0; i < rankCount; i++)
        {
            if (highScore[i] < score) //각 등수가 score보다 작으면 
            {
                for(int j = rankCount -1; j > i; j--) // 아래로 한칸씩 밀기
                {
                    highScore[j] = highScore[j - 1];
                    rankerName[j] = rankerName[j - 1];
                }
                highScore[i] = score;
                //rankerName[i] = "akakak";
                rankLines[i].SetData("새 랭커", highScore[i]);
                updatedIndex = i; // 밀리기 시작한 인덱스 저장해두기

                Vector3 newPos = inputField.transform.position;
                newPos.y = rankLines[i].transform.position.y;
                inputField.transform.position = newPos;
                inputField.gameObject.SetActive(true);
                break;
            }
        
        }
    }

for loof 에서 실행조건을 j > i    j가 i보다 클 때 윗줄을 데이터를 밑으로 한칸씩 밀어야하는데 i 대신 1을 넣어서 
무조건 3번이 실행되어 두번 째 줄까지 모든 데이터가 바뀌어버렸다

---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 20일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
오브젝트를 만들깨는 자식오브젝트와 부모오브젝트의 피봇과 로테이션을 일치시키는것이 좋다
빈오브젝트 하위에 자식들을 추가해서 오브젝트를 만들었는데 위치 또는 로테이션이 맘에 안들면 최상위 부모 오브젝트는 놔두고 자식오브젝트들의 로테이션, 위치를 조절하면 된다

---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 22일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
      Vector3 from = barrelBody.transform.position;
        Vector3 to;
	
	to 에 현재위치에서 앞쪽방향으로z축 range만큼 더하기 
	vector3를 새로만들어야하나? 도저히 답이 생각이 안났는데 그냥 transform.position + transform.foward * Range 해주면 끝나는 거였다.


 transform.foward ,backward, up, down, right,left 쉬운길이 있는데 왜 떠오르질 않는걸까. 연습부족인가 싶다
---------------------------------------------------------------------------------------------------------------------------------------------------------------
to 에서 발사각 기즈모 그리기
targetposition 의 x값에 angle을 +- 해주면 된다


Vector3 dir2 = Quaternion.AngleAxis(fireAngle, barrelBodyTransform.up) * barrelBodyTransform.forward; 이 코드에서 Quaternion.AngleAxis 함수에 설명을 읽어보면 float Angle과
Vector3 Axis(축) 만 받고있는데 뒤에 * barrelBodyTransform.forward; 이게 도대체 왜들어가는지, 이럴거면 파라미터를 하나 더 받아야하는거 아닌가 너무 어이가 없었다. 
그런데 생각해보니 Vector3 dir2 = vector3 타입으로 받으려고 하기때문에 * barrelBodyTransform.forward;  이걸 적어줘야하는거였다. 그게 아니면 생략해도 된다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 24일
---------------------------------------------------------------------------------------------------------------------------------------------------------------

public class UIobjectSpawner 에서 slot 오브젝트를 인스펙터에서 연결했음에도 불구하고 null 이 뜸.
원인 : Inventory클래스의 Start메서드에서 GameManager.UI_Spawner.Initialize(); 를 호출하는데 GameManager에서 UI_Spawner를 참조할때 new를 사용했으나 UI_Spawner는 monobihaviour 를
상속받아 제대로 초기화가 되지 않아 slot이 null이었던것

그래서 UI_Spawner 에서  MonoBehaviour 를 지워봤는데 유니티 생명주기함수는 물론 Instantiate 함수도 역시 사용이 안되 그만두었다.

결국 UI_Spawner 와 Inventory Class를 public 으로 선언해서 인스펙터에서 할당하기로 했다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------

함수를 오버로딩할까 하다가 널러블타입을 매개변수로 받아서 해봤다. 코드가 짧아지지만 좀 복잡해질 수도있을 것같다

---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 25일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
UI_Spawner 스크립트에서 Inventory 클래스를 선언하지도, 참조하지도 않았는데 
slots[Inventory.state].Add(newSlot); 또는  slots[Inventory.state].Add(newSlot); 어떻게 Inventory.state Inventory 클레스를 직접 참조할수있는지 의문이었다.

알아본결과 static으로 선언된 필드, 프로퍼티는 객체의 참조 없이도 사용할 수 있기때문에 문제가 없었던 것이다.
그렇기 때문에                 slots[GameManager.Inventory.state].Add(newSlot); 처음에 이렇게 할려고했는데 안되는 이유는 추측해보자면 직접 사용할 수 있는 것을 굳이 참조를 통해서 
사용하게하면 오히려 더 복잡해지기 때문이아닐까? 하는 추측을 해본다

그렇다면 Inventory의 참조를  GameManager가 갖고있는데 굳이  Inventory.state 을 static으로 선언해야하는가?
라는 의문이 들어서 그냥 public static Current_Inventory_State state; 에서 static을 제거하고  다른곳에서 참조할때 Inventory.state 이 아니라 GameManager.Inventory.state를 사용하기로 했다.
다른 데이터들과 접근방식의 통일성을 위해 이렇게 하는게 더 좋다고 판단했다
---------------------------------------------------------------------------------------------------------------------------------------------------------------
클래스가 static으로 선언되어있어도 해당 클래스의 하위 필드에 모두 접근할수 있다는 건아니다. 만약 이게 가능했다면  어떤 클레스에 엑세스가 가능한 순간 해당 클레스의 모든부분을
접근할 수 있다는 얘기가 된다. 
---------------------------------------------------------------------------------------------------------------------------------------------------------------
프로퍼티를 변경하지 않고 그냥 private필드를 수정하면 프로퍼티의 set함수가 호출되지 않는다
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  void Make_Slot(int? additional_Value = null)
    {
        int? count = 5 + additional_Value;
        for (int i = 0; i < count; i++)

만약 버튼을 통해 이 함수를 호출하게 되면  additional_Value는 null이 되고(중단점을 잡고 보면 0으로 나오는데 그런데도 count 역시 0으로 설정되서 for문이 실행되지 않는다.)
추측으론 additional_Value 이 null 일 경우 5 + null = null 이 되는 것 같다. 그렇기때문에 int? count = ( additional_Value ?? 0) 해주면 additional_Value 가 null 일때 0을 대입하라는 뜻으로
이렇게 하면 count가 5로 설정되어 for루프가 실행되게 된다.

---------------------------------------------------------------------------------------------------------------------------------------------------------------
6월 27일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
HpPotion 소환 위치 문제

아마도 애니메이션에서 위치를 강제로 설정하고있기때문인것 같다 
새 씬을 만들어 UnPack 한 후 pivot을 다시 설정해서 수정했다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 2일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
C#의 enum은 int(4바이트) 를 기반으로 작동한다
따라서 enum안의 컨텐츠가 몇개가 있든 할당되는 메모리의 총량은 enum 하나당 4바이트로 변하지 않는다

또한 Base 클레스에 public or protected Enum 을 선언하고 상속받은 자식 객체들에서 각각 enum을 다르게 설정해도  각각 독립된 enum값을 유지하게 된다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------

      if (item.IsStackable && slot.CurrentItem != null && item.name == slot.CurrentItem.name)
            {
                slot.ItemCount++;
                break;
            }

위 코드에서 만약 slot.CurrentItem != null 널 체크를 안해주면 slot.CurrentItem.name가 null인 상태로 item.name 과비교할때 크래시가된다
---------------------------------------------------------------------------------------------------------------------------------------------------------------
코루틴 시작을 StartCoroutine 없이 그냥 함수이름만 적으면 실행이 안된다..
---------------------------------------------------------------------------------------------------------------------------------------------------------------
어떤 이미지의 Color를 변경하고싶을 땐 값타입인 Color를 변경하려면 image.color.a = 0.5f; 이런식으로 직접 변경하는건 컴파일 에러가 난다 따라서
아래와같이 지역변수를 하나 만들고 그것의 알파값을 바꾼다음 적용하고싶은 이미지의 color에 대입해줘야한다.

var color = image.color;
color.a = 0.5f;
image.color = color;
---------------------------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 6일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
  private void UpdateSlotImage(ItemBase item, List<GameObject> slotList)
    {
        foreach (GameObject slotObject in slotList)
        {
            Slot slot = slotObject.GetComponent<Slot>();
            if (item.IsStackable && slot.CurrentItem != null && item.name == slot.CurrentItem.name)
            {
                slot.ItemCount++;
                break;
            }
            else if (slot.IsEmpty) //a+만약 슬롯이 비었다면
            {
                Image slotImage = slotObject.transform.GetChild(0).GetComponent<Image>();// 바꿔줄 이미지 컴포넌트 가져오기
                string spriteName = Enum.GetName(typeof(ItemImagePath), item.ItemImagePath);// enum의 이름을 string 변수에 넣어주기
                
                Sprite[] sprite = Resources.LoadAll<Sprite>($"ItemImage/Items");
                foreach (Sprite s in sprite)
                {
                    if (s.name == spriteName)
                    {
                        slotImage.sprite = s;
                        break;
                    }
                }
               // slotImage.sprite = sprite[spriteName];

                

                slot.IsEmpty = false;
                slot.CurrentItem = item;
                // 아이템을 추가했으므로 loop를 중단
                break;
            }
        }
  
    }

   slot.CurrentItem = item(ItemBase클래스); 으로 지정해주니(참조를 넘겨줌) item 인스턴스(오브젝트) 가 destroy 되는순간  slot.CurrentItem 도 null이 되버린다.

 ItemBase클레스의 slot.CurrentItem 변수 타입을 ItemBase 에서 string 으로 바꿔주고 slot.CurrentItem = item.name; 으로 바꿔서 해결했다.

---------------------------------------------------------------------------------------------------------------------------------------------------------------
7월 7일
---------------------------------------------------------------------------------------------------------------------------------------------------------------
TileMap Project내부

플레이어 가 움직일 때 
AttackAxis.rotation = quaternion.Euler(0, 0, 90); ...  자식오브젝트인 AttackAxis.rotation 이 수정되지 않는 문제

중단점 확인 결과
먼저 실행되는 FixedUpdate까지는 회전값이 0.7로 잘 들어가다가 Update로 점프하니 rotation값이 0으로 바뀜
즉 FixedUpdate와  Update 사이 뭔가 값이 변경된 것을 확인. 유니티 공식문서 확인 결과  도중 몇몇가지 과정을 거치는데 변수가 될만한게 에니메이션 관련 밖에 없는것 같아 
에니메이션을 확인 한 결과 AttackDown 에니메이션에 AttackAxis.rotation property 가 추가되있는것을 확인했다. 그리고 이것을 지웠더니 문제가 해결됐다.
Attack 애니메이션인데도 이동할때 영향을 줬던건 애니메이션 블랜딩때문일까?


